
#define STR1(x) #x
#define STR2(x) STR1(x)

bool my_fun0( const vector<double>& rhs, const vector<double>& lhs )
{
  assert( rhs.size() == lhs.size() );
    
  double n1=0, n2=0;
  const unsigned dim=rhs.size();
  for( unsigned i=0; i<dim; i++ )
  {
    n1 += rhs[i]*rhs[i];
    n2 += lhs[i]*lhs[i];
  }    
  return (n1 < n2);
}

bool my_fun1( const vector<double>& rhs, const vector<double>& lhs )
{
  assert( rhs.size() == lhs.size() );
    
  double n1=0, n2=0;
  const unsigned dim=rhs.size();
  for( unsigned i=0; i<dim; i++ )
  {
    n1 += rhs[i]*rhs[i];
    n2 += lhs[i]*lhs[i];
  }  
  return (fabs(n1-n2)<1e-5);
}

class CBase2
{
  public:
    CBase2( const std::string );
    virtual ~CBase2() {};
    
    void dump_info_xml( const string="" );
    double l2norm_t() { return m_t[0]*m_t[0]+m_t[1]*m_t[1]; };
  
    virtual void compute_contributions()=0;
 
    MPI_Comm mpi_communicator;
    gsl_multiroot_function_fdf m_fun;

    void find_new_t();
  protected:
    double m_T[2];
    double m_W[5];
    double m_V2[9];
    double m_I12; 
    double m_x[2];
    double m_f[2];
    double m_f_df[4];

    void generate_initial_points();
    void screening();
    void select_t();
    void compute_f_df();
    
    double m_t[2];
    double m_t_old[2];
    double m_xmin, m_xmax;
    double m_ymin, m_ymax;
    double m_zmin, m_zmax;
    double m_res;
    double m_res_old;
    double m_resp;
    double m_res_over_resp;
    double m_ti;    
    double m_final_error;
    double m_rMu;
    double m_dmu;
    double m_N;
    double m_L_halbe;

    vector<double> m_epsilon;
    vector<double> m_gs;
    vector<double> m_omega;
    vector<vector<double>> m_found_t;
    vector<vector<double>> m_t_guess;

    bool m_root;
    int m_rank;
    int m_max_iter;

    unsigned m_counter;
    unsigned m_global_refinement;
    unsigned m_total_no_cells;
    unsigned m_total_no_active_cells;    
    unsigned m_NA;
    unsigned m_Ndmu;
    unsigned m_no_initial_points;
    unsigned m_QN1[3];
    //unsigned m_QN2[3];
    
    ofstream m_computing_timer_log;
    TimerOutput m_computing_timer;    
    MyParameterHandler m_ph;
    ConditionalOStream pcout;

    string m_guess_str;
};

CBase2::CBase2( const std::string xmlfilename  ) 
  : 
  mpi_communicator(MPI_COMM_WORLD), 
  m_computing_timer_log("benchmark.txt"),
  m_computing_timer(mpi_communicator, m_computing_timer_log, TimerOutput::summary, TimerOutput:: cpu_and_wall_times ), 
  m_ph(xmlfilename),
  pcout (cout, (Utilities::MPI::this_mpi_process(mpi_communicator) == 0))
{
  m_root = (Utilities::MPI::this_mpi_process(mpi_communicator) == 0);
  MPI_Comm_rank(mpi_communicator, &m_rank);
 
  m_global_refinement = unsigned(m_ph.Get_Mesh("global_refinements",0));
}

void CBase2::generate_initial_points()
{
  for( auto& el : m_t_guess )
    el.clear();

  std::random_device rd;
  std::mt19937 gen(rd());
  std::uniform_real_distribution<> dis(-m_L_halbe, m_L_halbe);
  
  vector<double> tmp;
  for( unsigned n=0; n<m_no_initial_points; n++ ) 
  {
    tmp.push_back(dis(gen));
    tmp.push_back(dis(gen));
    m_t_guess.push_back(tmp);
    tmp.clear();
  }
}

void CBase2::screening()
{
  std::sort( m_found_t.begin(), m_found_t.end(), my_fun0 );
  m_found_t.erase( std::unique(m_found_t.begin(), m_found_t.end(), my_fun1), m_found_t.end() );  
}

void CBase2::compute_f_df()
{
  memset(m_f,0,2*sizeof(double));
  memset(m_f_df,0,4*sizeof(double));

  const double t0 = m_x[0];
  const double t1 = m_x[1];
  const double t0q = t0*t0;
  const double t1q = t1*t1;
  const double t0k = t0q*t0;
  const double t1k = t1q*t1;

  m_f[0] = t0*m_T[0] + t1*m_I12;
  m_f[0] += t0k*m_W[0] + 3*t0*t1q*m_W[2] + 3*t0q*t1*m_W[3] + t1k*m_W[4];
  m_f[0] += t0k*m_V2[0] + t0q*t1*(m_V2[1]+m_V2[6]) + t0*t1q*(m_V2[2]+m_V2[7]) + t1k*m_V2[8];
  m_f[1] = t1*m_T[1] + t0*m_I12; 
  m_f[1] += t1k*m_W[1] + 3*t0*t1q*m_W[4] + 3*t0q*t1*m_W[2] + t0k*m_W[3];
  m_f[1] += t0k*m_V2[6] + t0q*t1*(m_V2[7]+m_V2[3]) + t0*t1q*(m_V2[8]+m_V2[4]) + t1k*m_V2[5];

  // df0/dt0
  m_f_df[0] = m_T[0] + 3*t0q*m_W[0] + 3*t1q*m_W[2] + 6*t0*t1*m_W[3];
  m_f_df[0] += 3*t0q*m_V2[0] + 2*t0*t1*(m_V2[1]+m_V2[6]) + t1q*(m_V2[2]+m_V2[7]);

  // df0/dt1
  m_f_df[2] = m_I12 + 6*t0*t1*m_W[2] + 3*t0q*m_W[3] + 3*t1q*m_W[4];
  m_f_df[2] += t0q*(m_V2[1]+m_V2[6]) + 2*t0*t1*(m_V2[2]+m_V2[7]) + 3*t1q*m_V2[8];

  // df1/dt0
  m_f_df[1] = m_I12 + 3*t1q*m_W[4] + 6*t0*t1*m_W[2] + 3*t0q*m_W[3];
  m_f_df[1] += 3*t0q*m_V2[6] + 2*t0*t1*(m_V2[7]+m_V2[3]) + t1q*(m_V2[8]+m_V2[4]);

  // df1/dt1
  m_f_df[3] = m_T[1] + 3*t1q*m_W[1] + 6*t0*t1*m_W[4] + 3*t0q*m_W[2];
  m_f_df[3] += t0q*(m_V2[7]+m_V2[3]) + 2*t0*t1*(m_V2[8]+m_V2[4]) + 3*t1q*m_V2[5];
}

#endif
